<?xml version="1.0" encoding="UTF-8" ?>
<ChoregrapheProject xmlns="http://www.ald.softbankrobotics.com/schema/choregraphe/project.xsd" xar_version="3">
  <Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s behavior. Highest level possible." x="0" y="0">
    <bitmap>media/images/box/root.png</bitmap>
    <script language="4">
      <content>
        <![CDATA[]]>
      </content>
    </script>
    <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
    <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
    <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
    <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
    <Timeline enable="0">
      <BehaviorLayer name="behavior_layer1">
        <BehaviorKeyframe name="keyframe1" index="1">
          <Diagram>
            <Box name="Take Picture" id="1" localization="8" tooltip="" x="297" y="120">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[import os
import sys
import time
from naoqi import ALProxy

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        # Replace this with your robot's IP address
        IP = "10.50.30.157"
        PORT = 9559

        # Create a proxy to ALPhotoCapture
        try:
            photoCaptureProxy = ALProxy("ALPhotoCapture", IP, PORT)
        except Exception, e:
            print "Error when creating ALPhotoCapture proxy:"
            print str(e)
            self.logger.info("Error when creating ALPhotoCapture proxy:")
            self.logger.info(str(e))
            exit(1)
        photoCaptureProxy.setResolution(3)
        photoCaptureProxy.setPictureFormat("jpg")
        photoCaptureProxy.takePicture("/home/nao/recordings/cameras/", "image", True)
        self.onStopped()


    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Box name="Calculate Game State" id="2" localization="8" tooltip="" x="549" y="169">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[import numpy as np
import cv2

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

    def onLoad(self):
        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self):
        # Helper function to get width of bounding rect of a contour

        def getWidth(val):
            return cv2.boundingRect(val)[2]

        # Helper function to get height of bounding rect of a contour

        def getHeight(val):
            return cv2.boundingRect(val)[3]

        # Given a list of contours sorted by width, find the median width

        def getMedianWidth(conts):
            length = len(conts)
            if length % 2 == 1:
                return cv2.boundingRect(conts[length//2])[2]
            else:
                return ((cv2.boundingRect(conts[length//2])[2] + cv2.boundingRect(conts[length//2 - 1])[2]) / 2)

        # Given a list of contours sorted by height, find the median height

        def getMedianHeight(conts):
            length = len(conts)
            if length % 2 == 1:
                return cv2.boundingRect(conts[length//2])[3]
            else:
                return ((cv2.boundingRect(conts[length//2])[3] + cv2.boundingRect(conts[length//2 - 1])[3]) / 2)

        # create a 2d array to hold the gamestate
        gamestate = [["-", "-", "-"], ["-", "-", "-"], ["-", "-", "-"]]

        MARGIN = 5
        numBoardTiles = 9

        # kernel used for noise removal
        kernel = np.ones((7, 7), np.uint8)
        # Load a color image
        IM_DIR = '/home/nao/recordings/cameras/'
        IM_NAME = 'image.jpg'
        img = cv2.resize(cv2.imread(IM_DIR + IM_NAME),
            (1280, 960), interpolation=cv2.INTER_AREA)

        # turn into grayscale
        img_g = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        # turn into thresholded binary
        _, thresh1 = cv2.threshold(img_g, 127, 255, cv2.THRESH_BINARY)
        # remove noise from binary
        thresh1 = cv2.morphologyEx(thresh1, cv2.MORPH_OPEN, kernel)

        cv2.imwrite(IM_DIR + "binary.jpg", thresh1)


        # find and draw contours.
        # RETR_EXTERNAL retrieves only the extreme outer contours
        # RETR_LIST retrieves all contours
        _, contours, hierarchy = cv2.findContours(
            thresh1, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

        # find largest contour (outline of whole picture) and second largest contour (border of the actual game)
        largestArea = 0
        secondLargestArea = -1
        largestContour = 0
        secondLargestContour = 0
        i = 0
        for ct in contours:
            self.logger.info(cv2.boundingRect(ct))
            area = cv2.contourArea(ct)
            # self.logger.info("Second largest contour", secondLargestContour)
            if area > secondLargestArea:
                if area > largestArea:
                    secondLargestArea = largestArea
                    secondLargestContour = largestContour
                    largestArea = cv2.contourArea(ct)
                    largestContour = i
                else:
                    secondLargestArea = cv2.contourArea(ct)
                    secondLargestContour = i
            i = i + 1

        self.logger.info("Largest contour index " + str(cv2.boundingRect(contours[largestContour])))
        self.logger.info("Second largest contour index " +
            str(cv2.boundingRect(contours[secondLargestContour])))

        # Crop image to inside of second largest contour
        x1, y1, w1, h1 = cv2.boundingRect(contours[secondLargestContour])
        bwCropped = thresh1[y1+MARGIN:y1+h1-MARGIN, x1+MARGIN:x1+w1-MARGIN]
        colorCroppped = img[y1+MARGIN:y1+h1-MARGIN, x1+MARGIN:x1+w1-MARGIN]

        # Find contours in cropped image
        _, contours, hierarchy = cv2.findContours(
            bwCropped, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Clean out extra contours
        while len(contours) > numBoardTiles:
            # Find the furthest width from the median and the bounding rect of that width
            contours.sort(key=getWidth)
            medianWidth = getMedianWidth(contours)
            furthestFromMedianWidth = 0
            furthestFromMedianWidthBoundingRect = 0
            for ct in contours:
                tempWidth = abs(medianWidth - getWidth(ct))
                if tempWidth > furthestFromMedianWidth:
                    furthestFromMedianWidth = tempWidth
                    furthestFromMedianWidthBoundingRect = cv2.boundingRect(ct)
            # Find the furthest height from the median and the bounding rect of that height
            contours.sort(key=getHeight)
            medianHeight = getMedianHeight(contours)
            furthestFromMedianHeight = 0
            furthestFromMedianHeightBoundingRect = 0
            for ct in contours:
                tempHeight = abs(medianHeight - getHeight(ct))
                if tempHeight > furthestFromMedianHeight:
                    furthestFromMedianHeight = tempHeight
                    furthestFromMedianHeightBoundingRect = cv2.boundingRect(ct)
            # Take the larger difference between the width and height and delete the associated contour
            boundingRectToDelete = 0
            if furthestFromMedianWidth > furthestFromMedianHeight:
                boundingRectToDelete = furthestFromMedianWidthBoundingRect
            else:
                boundingRectToDelete = furthestFromMedianHeightBoundingRect
            i = 0
            for ct in contours:
                if cv2.boundingRect(ct) == boundingRectToDelete:
                    self.logger.info("Deleting" + str(cv2.boundingRect(ct)))
                    contours.pop(i)
                    self.logger.info("New length" + str(len(contours)))
                else:
                        i = i + 1

            for ct in contours:
                self.logger.info(str(cv2.boundingRect(ct)))

            x = 1
            y = 2
            for ct in contours:
                cv2.drawContours(colorCroppped, [ct], -1, (255, 0+x*10, 0+y*11), 15)
                x = x + 1
                y = y + 1

            cv2.imwrite(IM_DIR + "outers.jpg", img)

        # ======================================================
        # ======================================================
        # FIND INNER CONTOURS IN EACH TILE
        # ======================================================
        # ======================================================


        # get the image width and height
        img_width = colorCroppped.shape[1]
        img_height = colorCroppped.shape[0]
        # make a copy of the original image to draw the inner contours
        imgCopy = cv2.resize(cv2.imread(IM_DIR + IM_NAME),
            (1280, 960), interpolation=cv2.INTER_AREA)
        imgCopyCropped = imgCopy[y1+MARGIN:y1+h1-MARGIN, x1+MARGIN:x1+w1-MARGIN]

        tileCount = 0
        self.logger.info("finding contours in tiles")
        for cnt in contours:
            tileCount = tileCount+1
            # use boundingrect to get coordinates of tile
            x,y,w,h = cv2.boundingRect(cnt)
            tileArea = cv2.contourArea(cnt)
            # create new image from binary, for further analysis. Trim off the edge that has a line
            tile = bwCropped[y+MARGIN:y+h-MARGIN,x+MARGIN:x+w-MARGIN]
            # create new image from the image copy, so we can draw the inner contours easily
            imgCopyTile = imgCopyCropped[y+MARGIN:y+h-MARGIN,x+MARGIN:x+w-MARGIN]

            #determine the array indexes of the tile
            tileX = int(round(((x)/img_width)*3))
            tileY = int(round(((y)/img_height)*3))
            # self.logger.info(x, "  ", y)
            # self.logger.info(tileX, "  ", tileY)

            if tileX >= 0 and tileX < 3 and tileY >= 0 and tileY < 3:
                # find contours in the tile image. RETR_TREE retrieves all of the contours and reconstructs a full hierarchy of nested contours.
                _, c, hierarchy = cv2.findContours(tile, cv2.RETR_TREE , cv2.CHAIN_APPROX_SIMPLE)
                for ct in c:
                    # to prevent the tile finding itself as contour, and to ignore tiny contours
                    x2, y2, w2, h2 = cv2.boundingRect(ct)
                    if cv2.contourArea(ct) < tileArea * 0.70 and w2 > 0.2 * w and h2 > 0.2 * h:
                        number_of_white_pix = np.sum(tile[y2+MARGIN:y2+h2-MARGIN,x2+MARGIN:x2+w2-MARGIN] == 255)
                        number_of_black_pix = np.sum(tile[y2+MARGIN:y2+h2-MARGIN,x2+MARGIN:x2+w2-MARGIN] == 0)
                        self.logger.info(str(tileX) + str(tileY))
                        self.logger.info('Number of white pixels:' + str(number_of_white_pix))
                        self.logger.info('Number of black pixels:' + str(number_of_black_pix))
                        # the area needs to be at least 5% black in order to be legit
                        if (number_of_black_pix/number_of_white_pix > 0.05):
                            cv2.drawContours(imgCopyTile, [ct], -1, (255,0+tileX*127,0+tileY*127), 15)
                            #calculate the solitity
                            area = cv2.contourArea(ct)
                            hull = cv2.convexHull(ct)
                            hull_area = cv2.contourArea(hull)
                            if(hull_area != 0):
                                solidity = float(area)/hull_area
                            else:
                                solidity = 1

                            self.logger.info('Solidity', solidity)

                            # fill the gamestate with the right sign
                            if(solidity > 0.5):
                                gamestate[tileY][tileX] = "O"
                            else:
                                gamestate[tileY][tileX] = "X"
            else:
                self.logger.info("tile out of bounds:", tileX, tileY)
        #self.logger.info the gamestate
        self.logger.info("Gamestate:")
        for line in gamestate:
            linetxt = ""
            for cel in line:
                linetxt = linetxt + "|" + cel
            self.logger.info(linetxt)

        cv2.imwrite(IM_DIR + "inners.jpg", imgCopy)
        self.onStopped() #activate the output of the box


    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="2" />
            <Link inputowner="2" indexofinput="2" outputowner="1" indexofoutput="4" />
          </Diagram>
        </BehaviorKeyframe>
      </BehaviorLayer>
    </Timeline>
  </Box>
</ChoregrapheProject>
